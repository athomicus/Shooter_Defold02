function init(self)
	-- Initialize variables
	self.time = 0 -- Timer for tracking elapsed time
	self.pos = go.get_position() -- Get the initial position of the game object
	
	-- Define new target positions for animation
	local npos = go.get_position()	 
	npos.x = npos.x + 50 -- Move target position 50 units to the right			 
	npos.y = npos.y + 20 -- Move target position 20 units up
	
	-- Animate the game object's position in a ping-pong loop
	go.animate(".", "position.x", go.PLAYBACK_LOOP_PINGPONG, npos.x, go.EASING_INOUTSINE, 3) 

  -- Animate the current game object's y position in a ping-pong motion
-- Moves to npos.y over 3 seconds with a smooth easing effect (INOUTSINE)
-- Starts after a delay of 1 second
	go.animate(".", "position.y", go.PLAYBACK_LOOP_PINGPONG, npos.y, go.EASING_INOUTSINE, 3, 1) 
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") and message.enter then
    local enemy_id = go.get_id() -- Get the ID of the current game object  
    msg.post("#collisionobject", "disable") --disable the collision node in enemy to avoid multiple scores
    if message.other_group == hash("catcher") then 
      msg.post("#sprite", "disable")
      msg.post("EnemySpawn#spawn_enemy", "delete_enemy",{enemy_id=enemy_id })
      --pprint("zlapalem enemy_id: " .. enemy_id)
      return
    end
   --NO MATTER WHAT COLLISION POINTS ARE ADDED, ENEMY SHHOULD be DESTROYED
   --local what_hitted_enemy = message.other_id  
   --if tostring(what_hitted_enemy):find("Player") then
    
    if message.other_group == hash("player") then
      --pprint("zderzenie:"..enemy_id )
       -- msg.post("#collisionobject", "disable") --disable the collision node in enemy to avoid multiple scores
    end
      
		sound.play("#explosion")
		-- Send a message to the HUD GUI
		msg.post("Hud#myGUI", "score_up")
    --msg.post("EnemySpawn#spawn_enemy","remove_enemy_id",{enemy_id=enemy_id })-- Notify the enemy spawn script
    
    
		-- Play explosion animation and delete the game object after it finishes
		sprite.play_flipbook("#sprite", "explosion", function()
    msg.post("#sprite", "disable")
       
      -- Delete the game object after the animation completes
     msg.post("EnemySpawn#spawn_enemy", "delete_enemy",{enemy_id=enemy_id })
    end)
	end
end



function update(self, dt)
	-- Update the timer
	self.time = self.time + dt
	
end

--[[
-- Example of chained animations (commented out)
local up_down -- Forward declaration for up_down function
local left_right -- Forward declaration for left_right function

function up_down(self)
	-- Animate the y position and call left_right on completion
	go.animate(".", "position.y", go.PLAYBACK_ONCE_PINGPONG, 624, go.EASING_INOUTSINE, 2, 0, left_right)
end

function left_right(self)
	-- Animate the x position and call up_down on completion
	go.animate(".", "position.x", go.PLAYBACK_ONCE_PINGPONG, 660, go.EASING_INOUTSINE, 2, 0, up_down)    
end

function init(self)
	-- Start the chained animations
	up_down(self)
	-- Animate the scale and sprite tint in parallel
	go.animate(".", "scale.y", go.PLAYBACK_LOOP_PINGPONG, 0.5, go.EASING_INOUTSINE, 1)
	go.animate("#sprite", "tint.x", go.PLAYBACK_LOOP_PINGPONG, 0.0, go.EASING_INOUTSINE, 1.5)
end
--]]
--	up_down(self)
	-- Animate the scale and sprite tint in parallel	go.animate(".", "scale.y", go.PLAYBACK_LOOP_PINGPONG, 0.5, go.EASING_INOUTSINE, 1)	go.animate("#sprite", "tint.x", go.PLAYBACK_LOOP_PINGPONG, 0.0, go.EASING_INOUTSINE, 1.5)end--]]