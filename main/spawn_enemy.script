max_spawn_number = 5
list_of_enemies = {}



function init(self)
    self.spawned_enemy_number = 0
    -- Initialize the enemy factory or other necessary components
    self.enemy_factory = "#enemy_factory" -- Example factory reference
    self.spawn_timer = timer.delay(0.1, true, function() spawn_enemy(self) end)     -- Store the timer handle
end


function restart_spawn(self) --   -- Reset the enemy spawn count and clear the list of enemies
  self.spawned_enemy_number = 0 --spawnuj od nowa
  max_spawn_number = max_spawn_number + 1  
end

function remove_object_from_table(tbl, object)
    for i, v in ipairs(tbl) do
        if v == object then
            table.remove(tbl, i)
            break
        end
    end
end



function spawn_enemy(self) --spawn enemy and add ID to list_of_enemies
  
    if self.spawned_enemy_number >= max_spawn_number then
        return
    end
    self.spawned_enemy_number = self.spawned_enemy_number + 1
    local pos = vmath.vector3(math.random(60, 300), math.random(350, 550), 0)
    local enemy = factory.create(self.enemy_factory, pos) 
    if enemy then
        table.insert(list_of_enemies, enemy)
    else
        print("Error: Failed to create enemy")
    end
end

local function is_empty(list)
    return next(list) == nil -- Returns true if the list is empty, false otherwise
end


function delete_enemy_by_id(enemy_id)
    if enemy_id then
      timer.delay(2, false, 
        function()
            go.delete(enemy_id)            
        end)
    end
end

function enemy_attack_player(self,enemy_id)
    
    if enemy_id then     
      go.cancel_animations(enemy_id)
      --[[]
        if go.exists(enemy_id) then
        print("Enemy ID exist")
        local collision_path = enemy_id .. "#collisionobject"
        pprint("PATH_COL:"..collision_path) 
        msg.post(collision_path, "disable")
      end
      ]]
      player_x = go.get_position("Player#player").x
      go.animate(enemy_id,"position.x", go.PLAYBACK_ONCE_FORWARD, player_x, go.EASING_INOUTSINE, 3)
      go.animate(enemy_id,"position.y", go.PLAYBACK_ONCE_FORWARD, -42, go.EASING_INOUTSINE, 3) 
      delete_enemy_by_id(enemy_id)
      remove_object_from_table(list_of_enemies, enemy_id)
    else
        print("Error: Invalid enemy ID")
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("order_attack") then -- Handle the order to attack
      local _count  = #list_of_enemies
     
     
      -- pprint("przed atakiem: ".._count)
      --pprint(list_of_enemies)

        for i = #list_of_enemies, 1, -1 do  --iterate backwards to avoid index issues when removing elements
            --pprint("atakuje: "..list_of_enemies[i])
            -- Call the function to attack the player with the enemy ID
            -- Assuming enemy_attack_player is defined to handle the attack logic
           enemy_attack_player(self, list_of_enemies[i])
        end
        
        _count  = #list_of_enemies
      --  pprint("po ataku: ".._count)  
       -- pprint(list_of_enemies)
        --timer.delay(5, false,  function()  restart_spawn(self)  end)
    end

    if message_id == hash("remove_enemy_id") then
        for i, enemy in ipairs(list_of_enemies) do
            if enemy == message.enemy_id then
                table.remove(list_of_enemies, i)
                break
            end
        end
    end

    if message_id==hash("delete_enemy") then
      local path_sprite = message.enemy_id .. "#sprite"
      pprint(path_sprite)
      sprite.play_flipbook(path_sprite, "explosion", function() delete_enemy_by_id(message.enemy_id)   end)
    end


    if is_empty(list_of_enemies) then --all enemy destroyed
        timer.delay(5, false,  function()  restart_spawn(self) msg.post("Hud#myGUI", "restart_timer") end)    
      -- restart_spawn(self)
      --msg.post("Hud#myGUI", "restart_timer")
    end
end





