max_spawn_number = 5
list_of_enemies = {}



function init(self)
    self.spawned_enemy_number = 0
    -- Initialize the enemy factory or other necessary components
    self.enemy_factory = "#enemy_factory" -- Example factory reference
    -- Store the timer handle
    self.spawn_timer = timer.delay(0.1, true, function() spawn_enemy(self) end)
end


function restart_spawn(self)
  -- Reset the enemy spawn count and clear the list of enemies
  self.spawned_enemy_number = 0 --spawnuj od nowa
  max_spawn_number = max_spawn_number + 1   --ale o 1 enemmy more   
  pprint(list_of_enemies )
end

function spawn_enemy(self)
    if self.spawned_enemy_number >= max_spawn_number then
        return
    end
    self.spawned_enemy_number = self.spawned_enemy_number + 1
    local pos = vmath.vector3(math.random(60, 300), math.random(350, 550), 0)
    local enemy = factory.create(self.enemy_factory, pos)
    if enemy then
        table.insert(list_of_enemies, enemy)
    else
        print("Error: Failed to create enemy")
    end
end

local function is_empty(list)
    return next(list) == nil -- Returns true if the list is empty, false otherwise
end


function delete_enemy_by_id(enemy_id)
    if enemy_id then
      timer.delay(2, false, 
        function()
            go.delete(enemy_id)
            msg.post("Hud#myGUI", "restart_timer")
        end)
    end
end

function stop_enemy_animation(self,enemy_id)
    if enemy_id then
      go.cancel_animations(enemy_id)--, "euler.z")
      player_x = go.get_position("Player#player").x
      go.animate(enemy_id,"position.x", go.PLAYBACK_ONCE_FORWARD, player_x, go.EASING_INOUTEXPO, 0.3)
      go.animate(enemy_id,"position.y", go.PLAYBACK_ONCE_FORWARD, -12, go.EASING_INOUTEXPO, 0.3) --EASING_LINEAR
      --go.delete(enemy_id,2) -- Deletes the game object with the specified ID
      delete_enemy_by_id(enemy_id)
      list_of_enemies = {} -- Clear the list of enemies
      restart_spawn(self)
    else
        print("Error: Invalid enemy ID")
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("order_attack") then
        -- Handle the order to attack
        for _, enemy in ipairs(list_of_enemies) do
          --print(enemy)
          stop_enemy_animation(self,  enemy)
             --local e = go.g
            --enemy.cancel_animations(".", "euler.z")
        end
    end

    if message_id == hash("remove_enemy_id") then
        for i, enemy in ipairs(list_of_enemies) do
           -- print(enemy) -- Debugging output
            if enemy == message.enemy_id then
                table.remove(list_of_enemies, i)
                break
            end
        end
    end

    if is_empty(list_of_enemies) then --all enemy destroyed
        restart_spawn(self)
        msg.post("Hud#myGUI", "restart_timer")
    end
end





